SELECT 'Upgrading MetaStore schema from 2.1.1000 to 2.1.2000' AS Status from dual;

@044-HIVE-16997.oracle.sql;
@045-HIVE-16886.oracle.sql;

UPDATE VERSION SET SCHEMA_VERSION='2.1.2000', VERSION_COMMENT='Hive release version 2.1.2000' where VER_ID=1;
SELECT 'Finished upgrading MetaStore schema from 2.1.1000 to 2.1.2000' AS Status from dual;

-- upgrade to 2.1.2000
SELECT 'Upgrading MetaStore schema from 2.1.2000 to 3.0.0' AS Status from dual;

--@037-HIVE-14496.oracle.sql;
-- Step 1: Add the column allowing null
ALTER TABLE TBLS ADD IS_REWRITE_ENABLED NUMBER(1) NULL;

 -- Step 2: Replace the null with default value (false)
UPDATE TBLS SET IS_REWRITE_ENABLED = 0;

-- Step 3: Alter the column to disallow null values
ALTER TABLE TBLS MODIFY(IS_REWRITE_ENABLED DEFAULT 0);
ALTER TABLE TBLS MODIFY(IS_REWRITE_ENABLED NOT NULL);
ALTER TABLE TBLS ADD CONSTRAINT REWRITE_CHECK CHECK (IS_REWRITE_ENABLED IN (1,0));

--@040-HIVE-16399.oracle.sql;
CREATE INDEX TC_TXNID_INDEX ON TXN_COMPONENTS (TC_TXNID);

--@041-HIVE-16556.oracle.sql;
CREATE TABLE METASTORE_DB_PROPERTIES
(
  PROPERTY_KEY VARCHAR(255) NOT NULL,
  PROPERTY_VALUE VARCHAR(1000) NOT NULL,
  DESCRIPTION VARCHAR(1000)
);

ALTER TABLE METASTORE_DB_PROPERTIES ADD CONSTRAINT PROPERTY_KEY_PK PRIMARY KEY (PROPERTY_KEY);

--@042-HIVE-16575.oracle.sql;
CREATE INDEX CONSTRAINTS_CT_INDEX ON KEY_CONSTRAINTS(CONSTRAINT_TYPE);

--@043-HIVE-16922.oracle.sql;
UPDATE SERDE_PARAMS
SET PARAM_KEY='collection.delim'
WHERE PARAM_KEY='colelction.delim';

--@046-HIVE-17566.oracle.sql;
CREATE TABLE WM_RESOURCEPLAN
(
    RP_ID NUMBER NOT NULL,
    "NAME" VARCHAR2(128) NOT NULL,
    QUERY_PARALLELISM NUMBER(10),
    STATUS VARCHAR2(20) NOT NULL,
    DEFAULT_POOL_ID NUMBER
);

ALTER TABLE WM_RESOURCEPLAN ADD CONSTRAINT WM_RESOURCEPLAN_PK PRIMARY KEY (RP_ID);

CREATE UNIQUE INDEX UNIQUE_WM_RESOURCEPLAN ON WM_RESOURCEPLAN ("NAME");

CREATE TABLE WM_POOL
(
    POOL_ID NUMBER NOT NULL,
    RP_ID NUMBER NOT NULL,
    PATH VARCHAR2(1024) NOT NULL,
    ALLOC_FRACTION NUMBER,
    QUERY_PARALLELISM NUMBER(10),
    SCHEDULING_POLICY VARCHAR2(1024)
);

ALTER TABLE WM_POOL ADD CONSTRAINT WM_POOL_PK PRIMARY KEY (POOL_ID);

CREATE UNIQUE INDEX UNIQUE_WM_POOL ON WM_POOL (RP_ID, PATH);
ALTER TABLE WM_POOL ADD CONSTRAINT WM_POOL_FK1 FOREIGN KEY (RP_ID) REFERENCES WM_RESOURCEPLAN (RP_ID);


CREATE TABLE WM_TRIGGER
(
    TRIGGER_ID NUMBER NOT NULL,
    RP_ID NUMBER NOT NULL,
    "NAME" VARCHAR2(128) NOT NULL,
    TRIGGER_EXPRESSION VARCHAR2(1024),
    ACTION_EXPRESSION VARCHAR2(1024),
    IS_IN_UNMANAGED NUMBER(1) DEFAULT 0 NOT NULL CHECK (IS_IN_UNMANAGED IN (1,0))
);

ALTER TABLE WM_TRIGGER ADD CONSTRAINT WM_TRIGGER_PK PRIMARY KEY (TRIGGER_ID);

CREATE UNIQUE INDEX UNIQUE_WM_TRIGGER ON WM_TRIGGER (RP_ID, "NAME");

ALTER TABLE WM_TRIGGER ADD CONSTRAINT WM_TRIGGER_FK1 FOREIGN KEY (RP_ID) REFERENCES WM_RESOURCEPLAN (RP_ID);


CREATE TABLE WM_POOL_TO_TRIGGER
(
    POOL_ID NUMBER NOT NULL,
    TRIGGER_ID NUMBER NOT NULL
);

ALTER TABLE WM_POOL_TO_TRIGGER ADD CONSTRAINT WM_POOL_TO_TRIGGER_PK PRIMARY KEY (POOL_ID, TRIGGER_ID);

ALTER TABLE WM_POOL_TO_TRIGGER ADD CONSTRAINT WM_POOL_TO_TRIGGER_FK1 FOREIGN KEY (POOL_ID) REFERENCES WM_POOL (POOL_ID);

ALTER TABLE WM_POOL_TO_TRIGGER ADD CONSTRAINT WM_POOL_TO_TRIGGER_FK2 FOREIGN KEY (TRIGGER_ID) REFERENCES WM_TRIGGER (TRIGGER_ID);


CREATE TABLE WM_MAPPING
(
    MAPPING_ID NUMBER NOT NULL,
    RP_ID NUMBER NOT NULL,
    ENTITY_TYPE VARCHAR2(128) NOT NULL,
    ENTITY_NAME VARCHAR2(128) NOT NULL,
    POOL_ID NUMBER NOT NULL,
    ORDERING NUMBER(10)
);

ALTER TABLE WM_MAPPING ADD CONSTRAINT WM_MAPPING_PK PRIMARY KEY (MAPPING_ID);

CREATE UNIQUE INDEX UNIQUE_WM_MAPPING ON WM_MAPPING (RP_ID, ENTITY_TYPE, ENTITY_NAME);

ALTER TABLE WM_MAPPING ADD CONSTRAINT WM_MAPPING_FK1 FOREIGN KEY (RP_ID) REFERENCES WM_RESOURCEPLAN (RP_ID);

ALTER TABLE WM_MAPPING ADD CONSTRAINT WM_MAPPING_FK2 FOREIGN KEY (POOL_ID) REFERENCES WM_POOL (POOL_ID);

-- Upgrades for Schema Registry objects
ALTER TABLE "SERDES" ADD "DESCRIPTION" VARCHAR(4000);
ALTER TABLE "SERDES" ADD "SERIALIZER_CLASS" VARCHAR(4000);
ALTER TABLE "SERDES" ADD "DESERIALIZER_CLASS" VARCHAR(4000);
ALTER TABLE "SERDES" ADD "SERDE_TYPE" INTEGER;

CREATE TABLE "I_SCHEMA" (
  "SCHEMA_ID" number primary key,
  "SCHEMA_TYPE" number not null,
  "NAME" varchar2(256) unique,
  "DB_ID" number references "DBS" ("DB_ID"),
  "COMPATIBILITY" number not null,
  "VALIDATION_LEVEL" number not null,
  "CAN_EVOLVE" number(1) not null,
  "SCHEMA_GROUP" varchar2(256),
  "DESCRIPTION" varchar2(4000)
);

CREATE TABLE "SCHEMA_VERSION" (
  "SCHEMA_VERSION_ID" number primary key,
  "SCHEMA_ID" number references "I_SCHEMA" ("SCHEMA_ID"),
  "VERSION" number not null,
  "CREATED_AT" number not null,
  "CD_ID" number references "CDS" ("CD_ID"), 
  "STATE" number not null,
  "DESCRIPTION" varchar2(4000),
  "SCHEMA_TEXT" clob,
  "FINGERPRINT" varchar2(256),
  "SCHEMA_VERSION_NAME" varchar2(256),
  "SERDE_ID" number references "SERDES" ("SERDE_ID"), 
  UNIQUE ("SCHEMA_ID", "VERSION")
);


-- 048-HIVE-14498
CREATE TABLE MV_CREATION_METADATA
(
    MV_CREATION_METADATA_ID NUMBER NOT NULL,
    CAT_NAME VARCHAR2(256) NOT NULL,
    DB_NAME VARCHAR2(128) NOT NULL,
    TBL_NAME VARCHAR2(256) NOT NULL,
    TXN_LIST CLOB NULL
);

ALTER TABLE MV_CREATION_METADATA ADD CONSTRAINT MV_CREATION_METADATA_PK PRIMARY KEY (MV_CREATION_METADATA_ID);

CREATE UNIQUE INDEX UNIQUE_TABLE ON MV_CREATION_METADATA ("DB_NAME", "TBL_NAME");

CREATE TABLE MV_TABLES_USED
(
    MV_CREATION_METADATA_ID NUMBER NOT NULL,
    TBL_ID NUMBER NOT NULL
);

ALTER TABLE MV_TABLES_USED ADD CONSTRAINT MV_TABLES_USED_FK1 FOREIGN KEY (MV_CREATION_METADATA_ID) REFERENCES MV_CREATION_METADATA (MV_CREATION_METADATA_ID);

ALTER TABLE MV_TABLES_USED ADD CONSTRAINT MV_TABLES_USED_FK2 FOREIGN KEY (TBL_ID) REFERENCES TBLS (TBL_ID);

ALTER TABLE COMPLETED_TXN_COMPONENTS ADD CTC_TIMESTAMP timestamp NULL;

UPDATE COMPLETED_TXN_COMPONENTS SET CTC_TIMESTAMP = CURRENT_TIMESTAMP;

ALTER TABLE COMPLETED_TXN_COMPONENTS MODIFY(CTC_TIMESTAMP DEFAULT CURRENT_TIMESTAMP);

ALTER TABLE COMPLETED_TXN_COMPONENTS MODIFY(CTC_TIMESTAMP NOT NULL);

CREATE INDEX COMPLETED_TXN_COMPONENTS_INDEX ON COMPLETED_TXN_COMPONENTS (CTC_DATABASE, CTC_TABLE, CTC_PARTITION);

-- 049-HIVE-18489
UPDATE FUNC_RU
  SET RESOURCE_URI = 's3a' || SUBSTR(RESOURCE_URI, 4)
  WHERE RESOURCE_URI LIKE 's3n://%' ;

UPDATE SKEWED_COL_VALUE_LOC_MAP
  SET LOCATION = 's3a' || SUBSTR(LOCATION, 4)
  WHERE LOCATION LIKE 's3n://%' ;

UPDATE SDS
  SET LOCATION = 's3a' || SUBSTR(LOCATION, 4)
  WHERE LOCATION LIKE 's3n://%' ;

UPDATE DBS
  SET DB_LOCATION_URI = 's3a' || SUBSTR(DB_LOCATION_URI, 4)
  WHERE DB_LOCATION_URI LIKE 's3n://%' ;

-- HIVE-18192
CREATE TABLE TXN_TO_WRITE_ID (
  T2W_TXNID NUMBER(19) NOT NULL,
  T2W_DATABASE VARCHAR2(128) NOT NULL,
  T2W_TABLE VARCHAR2(256) NOT NULL,
  T2W_WRITEID NUMBER(19) NOT NULL
);

CREATE UNIQUE INDEX TBL_TO_TXN_ID_IDX ON TXN_TO_WRITE_ID (T2W_DATABASE, T2W_TABLE, T2W_TXNID);
CREATE UNIQUE INDEX TBL_TO_WRITE_ID_IDX ON TXN_TO_WRITE_ID (T2W_DATABASE, T2W_TABLE, T2W_WRITEID);

CREATE TABLE NEXT_WRITE_ID (
  NWI_DATABASE VARCHAR2(128) NOT NULL,
  NWI_TABLE VARCHAR2(256) NOT NULL,
  NWI_NEXT NUMBER(19) NOT NULL
);

CREATE UNIQUE INDEX NEXT_WRITE_ID_IDX ON NEXT_WRITE_ID (NWI_DATABASE, NWI_TABLE);

ALTER TABLE COMPACTION_QUEUE RENAME COLUMN CQ_HIGHEST_TXN_ID TO CQ_HIGHEST_WRITE_ID;

ALTER TABLE COMPLETED_COMPACTIONS RENAME COLUMN CC_HIGHEST_TXN_ID TO CC_HIGHEST_WRITE_ID;

-- Modify txn_components/completed_txn_components tables to add write id.
ALTER TABLE TXN_COMPONENTS ADD TC_WRITEID number(19);
ALTER TABLE COMPLETED_TXN_COMPONENTS ADD CTC_WRITEID number(19);

-- HIVE-18726
-- add a new column to support default value for DEFAULT constraint
ALTER TABLE KEY_CONSTRAINTS ADD DEFAULT_VALUE VARCHAR(400);
ALTER TABLE KEY_CONSTRAINTS MODIFY (PARENT_CD_ID NULL);

ALTER TABLE HIVE_LOCKS MODIFY(HL_TXNID NOT NULL);

-- HIVE-18755, add catalogs
-- new catalogs table
CREATE TABLE CTLGS (
    CTLG_ID NUMBER PRIMARY KEY,
    "NAME" VARCHAR2(256),
    "DESC" VARCHAR2(4000),
    LOCATION_URI VARCHAR2(4000) NOT NULL,
    UNIQUE ("NAME")
);

-- Insert a default value.  The location is TBD.  Hive will fix this when it starts
INSERT INTO CTLGS VALUES (1, 'hive', 'Default catalog for Hive', 'TBD');

-- Drop the unique index on DBS
DROP INDEX UNIQUE_DATABASE;

-- Add the new column to the DBS table, can't put in the not null constraint yet
ALTER TABLE DBS ADD CTLG_NAME VARCHAR2(256);

-- Update all records in the DBS table to point to the Hive catalog
UPDATE DBS 
  SET "CTLG_NAME" = 'hive';

-- Add the not null constraint
ALTER TABLE DBS MODIFY CTLG_NAME NOT NULL;

-- Put back the unique index 
CREATE UNIQUE INDEX UNIQUE_DATABASE ON DBS ("NAME", CTLG_NAME);

-- Add the foreign key
ALTER TABLE DBS ADD CONSTRAINT CTLGS_FK FOREIGN KEY (CTLG_NAME) REFERENCES CTLGS ("NAME") INITIALLY DEFERRED;

-- Add columns to table stats and part stats
ALTER TABLE TAB_COL_STATS ADD CAT_NAME VARCHAR2(256);
ALTER TABLE PART_COL_STATS ADD CAT_NAME VARCHAR2(256);

-- Set the existing column names to Hive
UPDATE TAB_COL_STATS
  SET CAT_NAME = 'hive';
UPDATE PART_COL_STATS
  SET CAT_NAME = 'hive';

-- Add the not null constraint
ALTER TABLE TAB_COL_STATS MODIFY CAT_NAME NOT NULL;
ALTER TABLE PART_COL_STATS MODIFY CAT_NAME NOT NULL;

-- Rebuild the index for Part col stats.  No such index for table stats, which seems weird
DROP INDEX PCS_STATS_IDX;
CREATE INDEX PCS_STATS_IDX ON PART_COL_STATS (CAT_NAME, DB_NAME,TABLE_NAME,COLUMN_NAME,PARTITION_NAME);

-- Add column to partition events
ALTER TABLE PARTITION_EVENTS ADD CAT_NAME VARCHAR2(256);

-- Add column to notification log
ALTER TABLE NOTIFICATION_LOG ADD CAT_NAME VARCHAR2(256);

CREATE TABLE REPL_TXN_MAP (
  RTM_REPL_POLICY varchar(256) NOT NULL,
  RTM_SRC_TXN_ID number(19) NOT NULL,
  RTM_TARGET_TXN_ID number(19) NOT NULL,
  PRIMARY KEY (RTM_REPL_POLICY, RTM_SRC_TXN_ID)
);

INSERT INTO SEQUENCE_TABLE (SEQUENCE_NAME, NEXT_VAL) SELECT 'org.apache.hadoop.hive.metastore.model.MNotificationLog',1 FROM DUAL WHERE NOT EXISTS ( SELECT NEXT_VAL FROM SEQUENCE_TABLE WHERE SEQUENCE_NAME = 'org.apache.hadoop.hive.metastore.model.MNotificationLog');

-- HIVE-18747
CREATE TABLE MIN_HISTORY_LEVEL (
  MHL_TXNID NUMBER(19) NOT NULL,
  MHL_MIN_OPEN_TXNID NUMBER(19) NOT NULL,
  PRIMARY KEY(MHL_TXNID)
);

CREATE INDEX MIN_HISTORY_LEVEL_IDX ON MIN_HISTORY_LEVEL (MHL_MIN_OPEN_TXNID);

CREATE TABLE RUNTIME_STATS (
  RS_ID NUMBER primary key,
  CREATE_TIME NUMBER(10) NOT NULL,
  WEIGHT NUMBER(10) NOT NULL,
  PAYLOAD BLOB
);

CREATE INDEX IDX_RUNTIME_STATS_CREATE_TIME ON RUNTIME_STATS(CREATE_TIME);

-- HIVE-18193
-- Populate NEXT_WRITE_ID for each Transactional table and set next write ID same as next txn ID
INSERT INTO NEXT_WRITE_ID (NWI_DATABASE, NWI_TABLE, NWI_NEXT)
    SELECT * FROM
        (SELECT DB.NAME, TBL_INFO.TBL_NAME FROM DBS DB,
            (SELECT TBL.DB_ID, TBL.TBL_NAME FROM TBLS TBL,
                (SELECT TBL_ID FROM TABLE_PARAMS WHERE PARAM_KEY='transactional' AND to_char(PARAM_VALUE)='true') TBL_PARAM
            WHERE TBL.TBL_ID=TBL_PARAM.TBL_ID) TBL_INFO
        where DB.DB_ID=TBL_INFO.DB_ID) DB_TBL_NAME,
        (SELECT NTXN_NEXT FROM NEXT_TXN_ID) NEXT_WRITE;

-- Populate TXN_TO_WRITE_ID for each aborted/open txns and set write ID equal to txn ID
INSERT INTO TXN_TO_WRITE_ID (T2W_DATABASE, T2W_TABLE, T2W_TXNID, T2W_WRITEID)
    SELECT * FROM
        (SELECT DB.NAME, TBL_INFO.TBL_NAME FROM DBS DB,
            (SELECT TBL.DB_ID, TBL.TBL_NAME FROM TBLS TBL,
                (SELECT TBL_ID FROM TABLE_PARAMS WHERE PARAM_KEY='transactional' AND to_char(PARAM_VALUE)='true') TBL_PARAM
            WHERE TBL.TBL_ID=TBL_PARAM.TBL_ID) TBL_INFO
        where DB.DB_ID=TBL_INFO.DB_ID) DB_TBL_NAME,
        (SELECT TXN_ID, TXN_ID as WRITE_ID FROM TXNS) TXN_INFO;

-- Update TXN_COMPONENTS and COMPLETED_TXN_COMPONENTS for write ID which is same as txn ID
UPDATE TXN_COMPONENTS SET TC_WRITEID = TC_TXNID;
UPDATE COMPLETED_TXN_COMPONENTS SET CTC_WRITEID = CTC_TXNID;

-- These lines need to be last.  Insert any changes above.
UPDATE VERSION SET SCHEMA_VERSION='3.0.0', VERSION_COMMENT='Hive release version 3.0.0' where VER_ID=1;
SELECT 'Finished upgrading MetaStore schema from 2.1.2000 to 3.0.0' AS Status from dual;

-- HIVE-21077
ALTER TABLE CTLGS add CREATE_TIME NUMBER(10);

-- These lines need to be last.  Insert any changes above.
UPDATE VERSION SET SCHEMA_VERSION='3.0.1000', VERSION_COMMENT='Hive release version 3.0.1000' where VER_ID=1;
SELECT 'Upgraded MetaStore schema to 3.0.1000' AS Status from dual;

-- Upgrade MetaStore schema from 3.0.1000 to 3.1.0
SELECT 'Upgrading MetaStore schema from 3.0.1000 to 3.1.0' AS Status from dual;

-- HIVE-19440
ALTER TABLE GLOBAL_PRIVS ADD AUTHORIZER VARCHAR2(128) NULL;
DROP INDEX GLOBALPRIVILEGEINDEX;
CREATE UNIQUE INDEX GLOBALPRIVILEGEINDEX ON GLOBAL_PRIVS (AUTHORIZER,PRINCIPAL_NAME,PRINCIPAL_TYPE,USER_PRIV,GRANTOR,GRANTOR_TYPE);

ALTER TABLE DB_PRIVS ADD AUTHORIZER VARCHAR2(128) NULL;
DROP INDEX DBPRIVILEGEINDEX;
CREATE UNIQUE INDEX DBPRIVILEGEINDEX ON DB_PRIVS (AUTHORIZER,DB_ID,PRINCIPAL_NAME,PRINCIPAL_TYPE,DB_PRIV,GRANTOR,GRANTOR_TYPE);

ALTER TABLE TBL_PRIVS ADD AUTHORIZER VARCHAR2(128) NULL;
DROP INDEX TABLEPRIVILEGEINDEX;
CREATE INDEX TABLEPRIVILEGEINDEX ON TBL_PRIVS (AUTHORIZER,TBL_ID,PRINCIPAL_NAME,PRINCIPAL_TYPE,TBL_PRIV,GRANTOR,GRANTOR_TYPE);

ALTER TABLE PART_PRIVS ADD AUTHORIZER VARCHAR2(128) NULL;
DROP INDEX PARTPRIVILEGEINDEX;
CREATE INDEX PARTPRIVILEGEINDEX ON PART_PRIVS (AUTHORIZER,PART_ID,PRINCIPAL_NAME,PRINCIPAL_TYPE,PART_PRIV,GRANTOR,GRANTOR_TYPE);

ALTER TABLE TBL_COL_PRIVS ADD AUTHORIZER VARCHAR2(128) NULL;
DROP INDEX TABLECOLUMNPRIVILEGEINDEX;
CREATE INDEX TABLECOLUMNPRIVILEGEINDEX ON TBL_COL_PRIVS (AUTHORIZER,TBL_ID,"COLUMN_NAME",PRINCIPAL_NAME,PRINCIPAL_TYPE,TBL_COL_PRIV,GRANTOR,GRANTOR_TYPE);

ALTER TABLE PART_COL_PRIVS ADD AUTHORIZER VARCHAR2(128) NULL;
DROP INDEX PARTITIONCOLUMNPRIVILEGEINDEX;
CREATE INDEX PARTITIONCOLUMNPRIVILEGEINDEX ON PART_COL_PRIVS (AUTHORIZER,PART_ID,"COLUMN_NAME",PRINCIPAL_NAME,PRINCIPAL_TYPE,PART_COL_PRIV,GRANTOR,GRANTOR_TYPE);

CREATE INDEX TAB_COL_STATS_IDX ON TAB_COL_STATS (CAT_NAME, DB_NAME, TABLE_NAME, COLUMN_NAME);

-- HIVE-19340
ALTER TABLE TXNS ADD TXN_TYPE number(10) NULL;

-- HIVE-19027
-- add column MATERIALIZATION_TIME (bigint) to MV_CREATION_METADATA table
ALTER TABLE MV_CREATION_METADATA ADD MATERIALIZATION_TIME NUMBER NULL;
UPDATE MV_CREATION_METADATA SET MATERIALIZATION_TIME = 0;
ALTER TABLE MV_CREATION_METADATA MODIFY(MATERIALIZATION_TIME NOT NULL);

-- add column CTC_UPDATE_DELETE (char) to COMPLETED_TXN_COMPONENTS table
ALTER TABLE COMPLETED_TXN_COMPONENTS ADD CTC_UPDATE_DELETE char(1) NULL;
UPDATE COMPLETED_TXN_COMPONENTS SET CTC_UPDATE_DELETE = 'N';
ALTER TABLE COMPLETED_TXN_COMPONENTS MODIFY(CTC_UPDATE_DELETE NOT NULL);

CREATE TABLE MATERIALIZATION_REBUILD_LOCKS (
  MRL_TXN_ID NUMBER NOT NULL,
  MRL_DB_NAME VARCHAR(128) NOT NULL,
  MRL_TBL_NAME VARCHAR(256) NOT NULL,
  MRL_LAST_HEARTBEAT NUMBER NOT NULL,
  PRIMARY KEY(MRL_TXN_ID)
);

alter table TBLS add WRITE_ID number DEFAULT 0 NOT NULL;
alter table PARTITIONS add WRITE_ID number DEFAULT 0 NOT NULL;

-- HIVE-19267
CREATE TABLE TXN_WRITE_NOTIFICATION_LOG (
  WNL_ID number(19) NOT NULL,
  WNL_TXNID number(19) NOT NULL,
  WNL_WRITEID number(19) NOT NULL,
  WNL_DATABASE varchar(128) NOT NULL,
  WNL_TABLE varchar(128) NOT NULL,
  WNL_PARTITION varchar(767),
  WNL_TABLE_OBJ clob NOT NULL,
  WNL_PARTITION_OBJ clob,
  WNL_FILES clob,
  WNL_EVENT_TIME number(10) NOT NULL
);
CREATE INDEX TXN_WRITE_NOTIFICATION_LOG_IDX ON TXN_WRITE_NOTIFICATION_LOG (WNL_TXNID, WNL_DATABASE, WNL_TABLE, WNL_PARTITION);
INSERT INTO SEQUENCE_TABLE (SEQUENCE_NAME, NEXT_VAL) VALUES ('org.apache.hadoop.hive.metastore.model.MTxnWriteNotificationLog', 1);

-- HIVE-21063
CREATE UNIQUE INDEX NOTIFICATION_LOG_EVENT_ID ON NOTIFICATION_LOG(EVENT_ID);
-- HIVE-20221
ALTER TABLE PARTITION_PARAMS ADD (TEMP CLOB);
UPDATE PARTITION_PARAMS SET TEMP=PARAM_VALUE, PARAM_VALUE=NULL;
ALTER TABLE PARTITION_PARAMS DROP COLUMN PARAM_VALUE;
ALTER TABLE PARTITION_PARAMS RENAME COLUMN TEMP TO PARAM_VALUE;


-- These lines need to be last.  Insert any changes above.
UPDATE VERSION SET SCHEMA_VERSION='3.1.0', VERSION_COMMENT='Hive release version 3.1.0' where VER_ID=1;
SELECT 'Finished upgrading MetaStore schema from 3.0.1000 to 3.1.0' AS Status from dual;
SELECT 'Upgrading MetaStore schema from 3.1.0 to 3.1.1000' AS Status from dual;

-- These lines need to be last.  Insert any changes above.
UPDATE VERSION SET SCHEMA_VERSION='3.1.1000', VERSION_COMMENT='Hive release version 3.1.1000' where VER_ID=1;
SELECT 'Finished upgrading MetaStore schema from 3.1.0 to 3.1.1000' AS Status from dual;

-- Upgrading to 3.1.2000
SELECT 'Upgrading MetaStore schema from 3.1.1000 to 3.1.2000' AS Status from dual;

ALTER TABLE TAB_COL_STATS
ADD ENGINE character varying(128);

ALTER TABLE PART_COL_STATS
ADD ENGINE character varying(128);

--- Migrate Impala statistics from CDH to CDP. The TAB_COL_STATS table records
--- will be duplicated and the ENGINE field filled.
---
--- 1) Create a temporary table for Impala
CREATE TABLE TMP_TAB_COL_STATS AS SELECT * FROM TAB_COL_STATS;

--- 2) Create a sequence to increment the CS_ID column values
CREATE SEQUENCE mtablecolumnstatisticsseq START WITH 1 INCREMENT BY 1;

--- 3) Update the unique ID, ENGINE and number of nulls field
UPDATE TMP_TAB_COL_STATS
SET CS_ID=mtablecolumnstatisticsseq.nextval +
  (SELECT NEXT_VAL
    FROM SEQUENCE_TABLE
    WHERE SEQUENCE_NAME = 'org.apache.hadoop.hive.metastore.model.MTableColumnStatistics');
UPDATE TAB_COL_STATS SET ENGINE = 'hive' WHERE ENGINE IS NULL;
UPDATE PART_COL_STATS SET ENGINE = 'hive' WHERE ENGINE IS NULL;
UPDATE TMP_TAB_COL_STATS SET ENGINE = 'impala' WHERE ENGINE IS NULL;

--- 4) Ingest the values back to TAB_COL_STATS
INSERT INTO TAB_COL_STATS SELECT * FROM TMP_TAB_COL_STATS;

--- 5) Update the MTableColumnStatistics with new counter
UPDATE SEQUENCE_TABLE
SET NEXT_VAL = NEXT_VAL + mtablecolumnstatisticsseq.nextval
WHERE SEQUENCE_NAME = 'org.apache.hadoop.hive.metastore.model.MTableColumnStatistics';

--- 6) Drop the temporary table
DROP TABLE TMP_TAB_COL_STATS;
DROP SEQUENCE mtablecolumnstatisticsseq;

-- These lines need to be last.  Insert any changes above.
UPDATE VERSION SET SCHEMA_VERSION='3.1.2000', VERSION_COMMENT='Hive release version 3.1.2000' where VER_ID=1;
SELECT 'Finished upgrading MetaStore schema from 3.1.1000 to 3.1.2000' AS Status from dual;

-- Upgrade schema to 3.1.3000
SELECT 'Upgrading MetaStore schema from 3.1.2000 to 3.1.3000' AS Status from dual;
CREATE TABLE "SCHEDULED_QUERIES" (
	"SCHEDULED_QUERY_ID" number(19) NOT NULL,
	"CLUSTER_NAMESPACE" VARCHAR(256),
	"ENABLED" NUMBER(1) NOT NULL CHECK ("ENABLED" IN (1,0)),
	"NEXT_EXECUTION" INTEGER,
	"QUERY" VARCHAR(4000),
	"SCHEDULE" VARCHAR(256),
	"SCHEDULE_NAME" VARCHAR(256),
	"USER" VARCHAR(256),
	CONSTRAINT SCHEDULED_QUERIES_PK PRIMARY KEY ("SCHEDULED_QUERY_ID")
);

CREATE TABLE "SCHEDULED_EXECUTIONS" (
	"SCHEDULED_EXECUTION_ID" number(19) NOT NULL,
	"END_TIME" INTEGER,
	"ERROR_MESSAGE" VARCHAR(2000),
	"EXECUTOR_QUERY_ID" VARCHAR(256),
	"LAST_UPDATE_TIME" INTEGER,
	"SCHEDULED_QUERY_ID" number(19),
	"START_TIME" INTEGER,
	"STATE" VARCHAR(256),
	CONSTRAINT SCHEDULED_EXECUTIONS_PK PRIMARY KEY ("SCHEDULED_EXECUTION_ID"),
	CONSTRAINT SCHEDULED_EXECUTIONS_SCHQ_FK FOREIGN KEY ("SCHEDULED_QUERY_ID") REFERENCES "SCHEDULED_QUERIES"("SCHEDULED_QUERY_ID") ON DELETE CASCADE
);

CREATE INDEX IDX_SCHEDULED_EX_LAST_UPDATE ON "SCHEDULED_EXECUTIONS" ("LAST_UPDATE_TIME");
CREATE INDEX IDX_SCHEDULED_EX_SQ_ID ON "SCHEDULED_EXECUTIONS" ("SCHEDULED_QUERY_ID");

-- HIVE-22728
ALTER TABLE KEY_CONSTRAINTS DROP CONSTRAINT CONSTRAINTS_PK;
ALTER TABLE KEY_CONSTRAINTS ADD CONSTRAINT CONSTRAINTS_PK PRIMARY KEY (PARENT_TBL_ID, CONSTRAINT_NAME, POSITION);

-- HIVE-21487
CREATE INDEX COMPLETED_COMPACTIONS_RES ON COMPLETED_COMPACTIONS (CC_DATABASE,CC_TABLE,CC_PARTITION);

-- HIVE-22729
ALTER TABLE COMPACTION_QUEUE ADD CQ_ERROR_MESSAGE CLOB;
ALTER TABLE COMPLETED_COMPACTIONS ADD CC_ERROR_MESSAGE CLOB;

-- These lines need to be last.  Insert any changes above.
UPDATE VERSION SET SCHEMA_VERSION='3.1.3000', VERSION_COMMENT='Hive release version 3.1.3000' where VER_ID=1;
SELECT 'Finished upgrading MetaStore schema from 3.1.2000 to 3.1.3000' AS Status from dual;
