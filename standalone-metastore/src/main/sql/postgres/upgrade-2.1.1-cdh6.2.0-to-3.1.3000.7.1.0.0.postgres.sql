SELECT 'Upgrading MetaStore schema from 2.1.1000 to 2.1.2000';

\i 043-HIVE-16997.postgres.sql;
\i 044-HIVE-16886.postgres.sql;

UPDATE "VERSION" SET "SCHEMA_VERSION"='2.1.2000', "VERSION_COMMENT"='Hive release version 2.1.2000' where "VER_ID"=1;
SELECT 'Finished upgrading MetaStore schema from 2.1.1000 to 2.1.2000';

SELECT 'Upgrading MetaStore schema from 2.1.2000 to 3.0.0';

--\i 036-HIVE-14496.postgres.sql;
-- Step 1: Add the column allowing null
ALTER TABLE "TBLS" ADD COLUMN "IS_REWRITE_ENABLED" boolean NULL;

 -- Step 2: Replace the null with default value (false)
UPDATE "TBLS" SET "IS_REWRITE_ENABLED" = false;

-- Step 3: Alter the column to disallow null values
ALTER TABLE "TBLS" ALTER COLUMN "IS_REWRITE_ENABLED" SET NOT NULL;
ALTER TABLE "TBLS" ALTER COLUMN "IS_REWRITE_ENABLED" SET DEFAULT false;

--\i 039-HIVE-16399.postgres.sql;
CREATE INDEX TC_TXNID_INDEX ON TXN_COMPONENTS USING hash (TC_TXNID);

--\i 040-HIVE-16556.postgres.sql;
CREATE TABLE "METASTORE_DB_PROPERTIES"
(
  "PROPERTY_KEY" VARCHAR(255) NOT NULL,
  "PROPERTY_VALUE" VARCHAR(1000) NOT NULL,
  "DESCRIPTION" VARCHAR(1000)
);

ALTER TABLE ONLY "METASTORE_DB_PROPERTIES"
  ADD CONSTRAINT "PROPERTY_KEY_PK" PRIMARY KEY ("PROPERTY_KEY");

--\i 041-HIVE-16575.postgres.sql;
CREATE INDEX "CONSTRAINTS_CONSTRAINT_TYPE_INDEX" ON "KEY_CONSTRAINTS" USING BTREE ("CONSTRAINT_TYPE");

--\i 042-HIVE-16922.postgres.sql;
UPDATE "SERDE_PARAMS"
SET "PARAM_KEY"='collection.delim'
WHERE "PARAM_KEY"='colelction.delim';

--\i 045-HIVE-17566.postgres.sql;
CREATE TABLE "WM_RESOURCEPLAN" (
    "RP_ID" bigint NOT NULL,
    "NAME" character varying(128) NOT NULL,
    "QUERY_PARALLELISM" integer,
    "STATUS" character varying(20) NOT NULL,
    "DEFAULT_POOL_ID" bigint
);

ALTER TABLE ONLY "WM_RESOURCEPLAN"
    ADD CONSTRAINT "WM_RESOURCEPLAN_pkey" PRIMARY KEY ("RP_ID");

ALTER TABLE ONLY "WM_RESOURCEPLAN"
    ADD CONSTRAINT "UNIQUE_WM_RESOURCEPLAN" UNIQUE ("NAME");


CREATE TABLE "WM_POOL" (
    "POOL_ID" bigint NOT NULL,
    "RP_ID" bigint NOT NULL,
    "PATH" character varying(1024) NOT NULL,
    "ALLOC_FRACTION" double precision,
    "QUERY_PARALLELISM" integer,
    "SCHEDULING_POLICY" character varying(1024)
);

ALTER TABLE ONLY "WM_POOL"
    ADD CONSTRAINT "WM_POOL_pkey" PRIMARY KEY ("POOL_ID");

ALTER TABLE ONLY "WM_POOL"
    ADD CONSTRAINT "UNIQUE_WM_POOL" UNIQUE ("RP_ID", "PATH");

ALTER TABLE ONLY "WM_POOL"
    ADD CONSTRAINT "WM_POOL_FK1" FOREIGN KEY ("RP_ID") REFERENCES "WM_RESOURCEPLAN" ("RP_ID") DEFERRABLE;
ALTER TABLE ONLY "WM_RESOURCEPLAN"
    ADD CONSTRAINT "WM_RESOURCEPLAN_FK1" FOREIGN KEY ("DEFAULT_POOL_ID") REFERENCES "WM_POOL" ("POOL_ID") DEFERRABLE;


CREATE TABLE "WM_TRIGGER" (
    "TRIGGER_ID" bigint NOT NULL,
    "RP_ID" bigint NOT NULL,
    "NAME" character varying(128) NOT NULL,
    "TRIGGER_EXPRESSION" character varying(1024) DEFAULT NULL::character varying,
    "ACTION_EXPRESSION" character varying(1024) DEFAULT NULL::character varying,
    "IS_IN_UNMANAGED" smallint NOT NULL DEFAULT 0
);

ALTER TABLE ONLY "WM_TRIGGER"
    ADD CONSTRAINT "WM_TRIGGER_pkey" PRIMARY KEY ("TRIGGER_ID");

ALTER TABLE ONLY "WM_TRIGGER"
    ADD CONSTRAINT "UNIQUE_WM_TRIGGER" UNIQUE ("RP_ID", "NAME");

ALTER TABLE ONLY "WM_TRIGGER"
    ADD CONSTRAINT "WM_TRIGGER_FK1" FOREIGN KEY ("RP_ID") REFERENCES "WM_RESOURCEPLAN" ("RP_ID") DEFERRABLE;


CREATE TABLE "WM_POOL_TO_TRIGGER" (
    "POOL_ID" bigint NOT NULL,
    "TRIGGER_ID" bigint NOT NULL
);

ALTER TABLE ONLY "WM_POOL_TO_TRIGGER"
    ADD CONSTRAINT "WM_POOL_TO_TRIGGER_pkey" PRIMARY KEY ("POOL_ID", "TRIGGER_ID");

ALTER TABLE ONLY "WM_POOL_TO_TRIGGER"
    ADD CONSTRAINT "WM_POOL_TO_TRIGGER_FK1" FOREIGN KEY ("POOL_ID") REFERENCES "WM_POOL" ("POOL_ID") DEFERRABLE;

ALTER TABLE ONLY "WM_POOL_TO_TRIGGER"
    ADD CONSTRAINT "WM_POOL_TO_TRIGGER_FK2" FOREIGN KEY ("TRIGGER_ID") REFERENCES "WM_TRIGGER" ("TRIGGER_ID") DEFERRABLE;


CREATE TABLE "WM_MAPPING" (
    "MAPPING_ID" bigint NOT NULL,
    "RP_ID" bigint NOT NULL,
    "ENTITY_TYPE" character varying(128) NOT NULL,
    "ENTITY_NAME" character varying(128) NOT NULL,
    "POOL_ID" bigint,
    "ORDERING" integer
);

ALTER TABLE ONLY "WM_MAPPING"
    ADD CONSTRAINT "WM_MAPPING_pkey" PRIMARY KEY ("MAPPING_ID");

ALTER TABLE ONLY "WM_MAPPING"
    ADD CONSTRAINT "UNIQUE_WM_MAPPING" UNIQUE ("RP_ID", "ENTITY_TYPE", "ENTITY_NAME");

ALTER TABLE ONLY "WM_MAPPING"
    ADD CONSTRAINT "WM_MAPPING_FK1" FOREIGN KEY ("RP_ID") REFERENCES "WM_RESOURCEPLAN" ("RP_ID") DEFERRABLE;

ALTER TABLE ONLY "WM_MAPPING"
    ADD CONSTRAINT "WM_MAPPING_FK2" FOREIGN KEY ("POOL_ID") REFERENCES "WM_POOL" ("POOL_ID") DEFERRABLE;

-- Upgrades for Schema Registry objects
ALTER TABLE "SERDES" ADD COLUMN "DESCRIPTION" VARCHAR(4000);
ALTER TABLE "SERDES" ADD COLUMN "SERIALIZER_CLASS" VARCHAR(4000);
ALTER TABLE "SERDES" ADD COLUMN "DESERIALIZER_CLASS" VARCHAR(4000);
ALTER TABLE "SERDES" ADD COLUMN "SERDE_TYPE" INTEGER;

CREATE TABLE "I_SCHEMA" (
  "SCHEMA_ID" bigint primary key,
  "SCHEMA_TYPE" integer not null,
  "NAME" varchar(256) unique,
  "DB_ID" bigint references "DBS" ("DB_ID"),
  "COMPATIBILITY" integer not null,
  "VALIDATION_LEVEL" integer not null,
  "CAN_EVOLVE" boolean not null,
  "SCHEMA_GROUP" varchar(256),
  "DESCRIPTION" varchar(4000)
);

CREATE TABLE "SCHEMA_VERSION" (
  "SCHEMA_VERSION_ID" bigint primary key,
  "SCHEMA_ID" bigint references "I_SCHEMA" ("SCHEMA_ID"),
  "VERSION" integer not null,
  "CREATED_AT" bigint not null,
  "CD_ID" bigint references "CDS" ("CD_ID"), 
  "STATE" integer not null,
  "DESCRIPTION" varchar(4000),
  "SCHEMA_TEXT" text,
  "FINGERPRINT" varchar(256),
  "SCHEMA_VERSION_NAME" varchar(256),
  "SERDE_ID" bigint references "SERDES" ("SERDE_ID"), 
  unique ("SCHEMA_ID", "VERSION")
);


-- 047-HIVE-14498
CREATE TABLE "MV_CREATION_METADATA" (
    "MV_CREATION_METADATA_ID" bigint NOT NULL,
    "CAT_NAME" character varying(256) NOT NULL,
    "DB_NAME" character varying(128) NOT NULL,
    "TBL_NAME" character varying(256) NOT NULL,
    "TXN_LIST" text
);

CREATE TABLE "MV_TABLES_USED" (
    "MV_CREATION_METADATA_ID" bigint NOT NULL,
    "TBL_ID" bigint NOT NULL
);

ALTER TABLE ONLY "MV_CREATION_METADATA"
    ADD CONSTRAINT "MV_CREATION_METADATA_PK" PRIMARY KEY ("MV_CREATION_METADATA_ID");

CREATE INDEX "MV_UNIQUE_TABLE"
    ON "MV_CREATION_METADATA" USING btree ("TBL_NAME", "DB_NAME");

ALTER TABLE ONLY "MV_TABLES_USED"
    ADD CONSTRAINT "MV_TABLES_USED_FK1" FOREIGN KEY ("MV_CREATION_METADATA_ID") REFERENCES "MV_CREATION_METADATA" ("MV_CREATION_METADATA_ID") DEFERRABLE;

ALTER TABLE ONLY "MV_TABLES_USED"
    ADD CONSTRAINT "MV_TABLES_USED_FK2" FOREIGN KEY ("TBL_ID") REFERENCES "TBLS" ("TBL_ID") DEFERRABLE;

ALTER TABLE COMPLETED_TXN_COMPONENTS ADD COLUMN CTC_TIMESTAMP timestamp NULL;

UPDATE COMPLETED_TXN_COMPONENTS SET CTC_TIMESTAMP = CURRENT_TIMESTAMP;

ALTER TABLE COMPLETED_TXN_COMPONENTS ALTER COLUMN CTC_TIMESTAMP SET NOT NULL;

ALTER TABLE COMPLETED_TXN_COMPONENTS ALTER COLUMN CTC_TIMESTAMP SET DEFAULT CURRENT_TIMESTAMP;

CREATE INDEX COMPLETED_TXN_COMPONENTS_INDEX ON COMPLETED_TXN_COMPONENTS USING btree (CTC_DATABASE, CTC_TABLE, CTC_PARTITION);

-- 048-HIVE-18489
UPDATE "FUNC_RU"
  SET "RESOURCE_URI" = 's3a' || SUBSTR("RESOURCE_URI", 4)
  WHERE "RESOURCE_URI" LIKE 's3n://%' ;

UPDATE "SKEWED_COL_VALUE_LOC_MAP"
  SET "LOCATION" = 's3a' || SUBSTR("LOCATION", 4)
  WHERE "LOCATION" LIKE 's3n://%' ;

UPDATE "SDS"
  SET "LOCATION" = 's3a' || SUBSTR("LOCATION", 4)
  WHERE "LOCATION" LIKE 's3n://%' ;

UPDATE "DBS"
  SET "DB_LOCATION_URI" = 's3a' || SUBSTR("DB_LOCATION_URI", 4)
  WHERE "DB_LOCATION_URI" LIKE 's3n://%' ;

-- HIVE-18192
CREATE TABLE TXN_TO_WRITE_ID (
  T2W_TXNID bigint NOT NULL,
  T2W_DATABASE varchar(128) NOT NULL,
  T2W_TABLE varchar(256) NOT NULL,
  T2W_WRITEID bigint NOT NULL
);

CREATE UNIQUE INDEX TBL_TO_TXN_ID_IDX ON TXN_TO_WRITE_ID (T2W_DATABASE, T2W_TABLE, T2W_TXNID);
CREATE UNIQUE INDEX TBL_TO_WRITE_ID_IDX ON TXN_TO_WRITE_ID (T2W_DATABASE, T2W_TABLE, T2W_WRITEID);

CREATE TABLE NEXT_WRITE_ID (
  NWI_DATABASE varchar(128) NOT NULL,
  NWI_TABLE varchar(256) NOT NULL,
  NWI_NEXT bigint NOT NULL
);

CREATE UNIQUE INDEX NEXT_WRITE_ID_IDX ON NEXT_WRITE_ID (NWI_DATABASE, NWI_TABLE);

ALTER TABLE COMPACTION_QUEUE RENAME CQ_HIGHEST_TXN_ID TO CQ_HIGHEST_WRITE_ID;

ALTER TABLE COMPLETED_COMPACTIONS RENAME CC_HIGHEST_TXN_ID TO CC_HIGHEST_WRITE_ID;

-- Modify txn_components/completed_txn_components tables to add write id.
ALTER TABLE TXN_COMPONENTS ADD TC_WRITEID bigint;
ALTER TABLE COMPLETED_TXN_COMPONENTS ADD CTC_WRITEID bigint;

-- HIVE-18726
-- add a new column to support default value for DEFAULT constraint
ALTER TABLE "KEY_CONSTRAINTS" ADD COLUMN "DEFAULT_VALUE" VARCHAR(400);
ALTER TABLE "KEY_CONSTRAINTS" ALTER COLUMN "PARENT_CD_ID" DROP NOT NULL;

ALTER TABLE COMPLETED_TXN_COMPONENTS ALTER COLUMN CTC_TIMESTAMP SET NOT NULL;

ALTER TABLE HIVE_LOCKS ALTER COLUMN HL_TXNID SET NOT NULL;

-- HIVE-18755, add catalogs
-- new catalogs table
CREATE TABLE "CTLGS" (
    "CTLG_ID" BIGINT PRIMARY KEY,
    "NAME" VARCHAR(256) UNIQUE,
    "DESC" VARCHAR(4000),
    "LOCATION_URI" VARCHAR(4000) NOT NULL
);

-- Insert a default value.  The location is TBD.  Hive will fix this when it starts
INSERT INTO "CTLGS" VALUES (1, 'hive', 'Default catalog for Hive', 'TBD');

-- Drop the unique index on DBS
ALTER TABLE "DBS" DROP CONSTRAINT "UNIQUE_DATABASE";

-- Add the new column to the DBS table, can't put in the not null constraint yet
ALTER TABLE "DBS" ADD "CTLG_NAME" VARCHAR(256);

-- Update all records in the DBS table to point to the Hive catalog
UPDATE "DBS" 
  SET "CTLG_NAME" = 'hive';

-- Add the not null constraint
ALTER TABLE "DBS" ALTER COLUMN "CTLG_NAME" SET NOT NULL;

-- Put back the unique index 
ALTER TABLE "DBS" ADD CONSTRAINT "UNIQUE_DATABASE" UNIQUE ("NAME", "CTLG_NAME");

-- Add the foreign key
ALTER TABLE "DBS" ADD CONSTRAINT "DBS_FK1" FOREIGN KEY ("CTLG_NAME") REFERENCES "CTLGS" ("NAME");

-- Add columns to table stats and part stats
ALTER TABLE "TAB_COL_STATS" ADD "CAT_NAME" varchar(256);
ALTER TABLE "PART_COL_STATS" ADD "CAT_NAME" varchar(256);

-- Set the existing column names to Hive
UPDATE "TAB_COL_STATS"
  SET "CAT_NAME" = 'hive';
UPDATE "PART_COL_STATS"
  SET "CAT_NAME" = 'hive';

-- Add the not null constraint
ALTER TABLE "TAB_COL_STATS" ALTER COLUMN "CAT_NAME" SET NOT NULL;
ALTER TABLE "PART_COL_STATS" ALTER COLUMN "CAT_NAME" SET NOT NULL;

-- Rebuild the index for Part col stats.  No such index for table stats, which seems weird
DROP INDEX "PCS_STATS_IDX";
CREATE INDEX "PCS_STATS_IDX" ON "PART_COL_STATS" ("CAT_NAME", "DB_NAME", "TABLE_NAME", "COLUMN_NAME", "PARTITION_NAME");

-- Add column to partition event
ALTER TABLE "PARTITION_EVENTS" ADD "CAT_NAME" varchar(256);

-- Add column to notification log
ALTER TABLE "NOTIFICATION_LOG" ADD "CAT_NAME" varchar(256);

CREATE TABLE REPL_TXN_MAP (
  RTM_REPL_POLICY varchar(256) NOT NULL,
  RTM_SRC_TXN_ID bigint NOT NULL,
  RTM_TARGET_TXN_ID bigint NOT NULL,
  PRIMARY KEY (RTM_REPL_POLICY, RTM_SRC_TXN_ID)
);

INSERT INTO "SEQUENCE_TABLE" ("SEQUENCE_NAME", "NEXT_VAL") SELECT 'org.apache.hadoop.hive.metastore.model.MNotificationLog',1 WHERE NOT EXISTS ( SELECT "NEXT_VAL" FROM "SEQUENCE_TABLE" WHERE "SEQUENCE_NAME" = 'org.apache.hadoop.hive.metastore.model.MNotificationLog');

-- HIVE_18747
CREATE TABLE MIN_HISTORY_LEVEL (
  MHL_TXNID bigint NOT NULL,
  MHL_MIN_OPEN_TXNID bigint NOT NULL,
  PRIMARY KEY(MHL_TXNID)
);

CREATE INDEX MIN_HISTORY_LEVEL_IDX ON MIN_HISTORY_LEVEL (MHL_MIN_OPEN_TXNID);

CREATE TABLE RUNTIME_STATS (
 RS_ID bigint primary key,
 CREATE_TIME bigint NOT NULL,
 WEIGHT bigint NOT NULL,
 PAYLOAD bytea
);

CREATE INDEX IDX_RUNTIME_STATS_CREATE_TIME ON RUNTIME_STATS(CREATE_TIME);

-- HIVE-18193
-- Populate NEXT_WRITE_ID for each Transactional table and set next write ID same as next txn ID
INSERT INTO NEXT_WRITE_ID (NWI_DATABASE, NWI_TABLE, NWI_NEXT)
    SELECT * FROM
        (SELECT "DB"."NAME", "TBL_INFO"."TBL_NAME" FROM "DBS" "DB",
            (SELECT "TBL"."DB_ID", "TBL"."TBL_NAME" FROM "TBLS" "TBL",
                (SELECT "TBL_ID" FROM "TABLE_PARAMS" WHERE "PARAM_KEY"='transactional' AND "PARAM_VALUE"='true') "TBL_PARAM"
            WHERE "TBL"."TBL_ID"="TBL_PARAM"."TBL_ID") "TBL_INFO"
        where "DB"."DB_ID"="TBL_INFO"."DB_ID") "DB_TBL_NAME",
        (SELECT NTXN_NEXT FROM NEXT_TXN_ID) "NEXT_WRITE";

-- Populate TXN_TO_WRITE_ID for each aborted/open txns and set write ID equal to txn ID
INSERT INTO TXN_TO_WRITE_ID (T2W_DATABASE, T2W_TABLE, T2W_TXNID, T2W_WRITEID)
    SELECT * FROM
        (SELECT "DB"."NAME", "TBL_INFO"."TBL_NAME" FROM "DBS" "DB",
            (SELECT "TBL"."DB_ID", "TBL"."TBL_NAME" FROM "TBLS" "TBL",
                (SELECT "TBL_ID" FROM "TABLE_PARAMS" WHERE "PARAM_KEY"='transactional' AND "PARAM_VALUE"='true') "TBL_PARAM"
            WHERE "TBL"."TBL_ID"="TBL_PARAM"."TBL_ID") "TBL_INFO"
        where "DB"."DB_ID"="TBL_INFO"."DB_ID") "DB_TBL_NAME",
        (SELECT TXN_ID, TXN_ID as WRITE_ID FROM TXNS) "TXN_INFO";

-- Update TXN_COMPONENTS and COMPLETED_TXN_COMPONENTS for write ID which is same as txn ID
UPDATE TXN_COMPONENTS SET TC_WRITEID = TC_TXNID;
UPDATE COMPLETED_TXN_COMPONENTS SET CTC_WRITEID = CTC_TXNID;

-- These lines need to be last.  Insert any changes above.
UPDATE "VERSION" SET "SCHEMA_VERSION"='3.0.0', "VERSION_COMMENT"='Hive release version 3.0.0' where "VER_ID"=1;
SELECT 'Finished upgrading MetaStore schema from 2.1.2000 to 3.0.0';

-- HIVE-21077
ALTER TABLE "CTLGS" ADD "CREATE_TIME" BIGINT;

UPDATE "VERSION" SET "SCHEMA_VERSION"='3.0.1000', "VERSION_COMMENT"='Hive release version 3.0.1000' where "VER_ID"=1;
SELECT 'Finished upgrading MetaStore schema from 3.0.0 to 3.0.1000';

-- Upgrading schema to 3.1.0
SELECT 'Upgrading MetaStore schema from 3.0.1000 to 3.1.0';

-- HIVE-19440
ALTER TABLE "GLOBAL_PRIVS" ADD COLUMN "AUTHORIZER" character varying(128) DEFAULT NULL::character varying;
ALTER TABLE "GLOBAL_PRIVS" DROP CONSTRAINT "GLOBALPRIVILEGEINDEX";
ALTER TABLE ONLY "GLOBAL_PRIVS"
    ADD CONSTRAINT "GLOBALPRIVILEGEINDEX" UNIQUE ("AUTHORIZER", "PRINCIPAL_NAME", "PRINCIPAL_TYPE", "USER_PRIV", "GRANTOR", "GRANTOR_TYPE");

ALTER TABLE "DB_PRIVS" ADD COLUMN "AUTHORIZER" character varying(128) DEFAULT NULL::character varying;
ALTER TABLE "DB_PRIVS" DROP CONSTRAINT "DBPRIVILEGEINDEX";
ALTER TABLE ONLY "DB_PRIVS"
    ADD CONSTRAINT "DBPRIVILEGEINDEX" UNIQUE ("AUTHORIZER", "DB_ID", "PRINCIPAL_NAME", "PRINCIPAL_TYPE", "DB_PRIV", "GRANTOR", "GRANTOR_TYPE");

ALTER TABLE "TBL_PRIVS" ADD COLUMN "AUTHORIZER" character varying(128) DEFAULT NULL::character varying;
DROP INDEX "TABLEPRIVILEGEINDEX";
CREATE INDEX "TABLEPRIVILEGEINDEX" ON "TBL_PRIVS" USING btree ("AUTHORIZER", "TBL_ID", "PRINCIPAL_NAME", "PRINCIPAL_TYPE", "TBL_PRIV", "GRANTOR", "GRANTOR_TYPE");

ALTER TABLE "PART_PRIVS" ADD COLUMN "AUTHORIZER" character varying(128) DEFAULT NULL::character varying;
DROP INDEX "PARTPRIVILEGEINDEX";
CREATE INDEX "PARTPRIVILEGEINDEX" ON "PART_PRIVS" USING btree ("AUTHORIZER", "PART_ID", "PRINCIPAL_NAME", "PRINCIPAL_TYPE", "PART_PRIV", "GRANTOR", "GRANTOR_TYPE");

ALTER TABLE "TBL_COL_PRIVS" ADD COLUMN "AUTHORIZER" character varying(128) DEFAULT NULL::character varying;
DROP INDEX "TABLECOLUMNPRIVILEGEINDEX";
CREATE INDEX "TABLECOLUMNPRIVILEGEINDEX" ON "TBL_COL_PRIVS" USING btree ("AUTHORIZER", "TBL_ID", "COLUMN_NAME", "PRINCIPAL_NAME", "PRINCIPAL_TYPE", "TBL_COL_PRIV", "GRANTOR", "GRANTOR_TYPE");

ALTER TABLE "PART_COL_PRIVS" ADD COLUMN "AUTHORIZER" character varying(128) DEFAULT NULL::character varying;
DROP INDEX "PARTITIONCOLUMNPRIVILEGEINDEX";
CREATE INDEX "PARTITIONCOLUMNPRIVILEGEINDEX" ON "PART_COL_PRIVS" USING btree ("AUTHORIZER", "PART_ID", "COLUMN_NAME", "PRINCIPAL_NAME", "PRINCIPAL_TYPE", "PART_COL_PRIV", "GRANTOR", "GRANTOR_TYPE");

CREATE INDEX "TAB_COL_STATS_IDX" ON "TAB_COL_STATS" USING btree ("CAT_NAME", "DB_NAME","TABLE_NAME","COLUMN_NAME");

-- HIVE-19340
ALTER TABLE TXNS ADD COLUMN TXN_TYPE integer DEFAULT NULL;

-- HIVE-19027
-- add column MATERIALIZATION_TIME (bigint) to MV_CREATION_METADATA table
ALTER TABLE "MV_CREATION_METADATA" ADD COLUMN "MATERIALIZATION_TIME" bigint NULL;
UPDATE "MV_CREATION_METADATA" SET "MATERIALIZATION_TIME" = 0;
ALTER TABLE "MV_CREATION_METADATA" ALTER COLUMN "MATERIALIZATION_TIME" SET NOT NULL;

-- add column CTC_UPDATE_DELETE (char) to COMPLETED_TXN_COMPONENTS table
ALTER TABLE COMPLETED_TXN_COMPONENTS ADD COLUMN CTC_UPDATE_DELETE char(1) NULL;
UPDATE COMPLETED_TXN_COMPONENTS SET CTC_UPDATE_DELETE = 'N';
ALTER TABLE COMPLETED_TXN_COMPONENTS ALTER COLUMN CTC_UPDATE_DELETE SET NOT NULL;

CREATE TABLE MATERIALIZATION_REBUILD_LOCKS (
  MRL_TXN_ID bigint NOT NULL,
  MRL_DB_NAME varchar(128) NOT NULL,
  MRL_TBL_NAME varchar(256) NOT NULL,
  MRL_LAST_HEARTBEAT bigint NOT NULL,
  PRIMARY KEY(MRL_TXN_ID)
);

-- HIVE-19416
ALTER TABLE "TBLS" ADD COLUMN "WRITE_ID" bigint DEFAULT 0;
ALTER TABLE "PARTITIONS" ADD COLUMN "WRITE_ID" bigint DEFAULT 0;

-- HIVE-19267
CREATE TABLE "TXN_WRITE_NOTIFICATION_LOG" (
  "WNL_ID" bigint NOT NULL,
  "WNL_TXNID" bigint NOT NULL,
  "WNL_WRITEID" bigint NOT NULL,
  "WNL_DATABASE" varchar(128) NOT NULL,
  "WNL_TABLE" varchar(128) NOT NULL,
  "WNL_PARTITION" varchar(767) NOT NULL,
  "WNL_TABLE_OBJ" text NOT NULL,
  "WNL_PARTITION_OBJ" text,
  "WNL_FILES" text,
  "WNL_EVENT_TIME" integer NOT NULL,
  PRIMARY KEY ("WNL_TXNID", "WNL_DATABASE", "WNL_TABLE", "WNL_PARTITION")
);
INSERT INTO "SEQUENCE_TABLE" ("SEQUENCE_NAME", "NEXT_VAL") VALUES ('org.apache.hadoop.hive.metastore.model.MTxnWriteNotificationLog', 1);

-- HIVE-21063
CREATE UNIQUE INDEX "NOTIFICATION_LOG_EVENT_ID" ON "NOTIFICATION_LOG" USING btree ("EVENT_ID");
-- HIVE-20221
alter table "PARTITION_PARAMS" alter column "PARAM_VALUE" type text using cast("PARAM_VALUE" as text);


-- These lines need to be last.  Insert any changes above.
UPDATE "VERSION" SET "SCHEMA_VERSION"='3.1.0', "VERSION_COMMENT"='Hive release version 3.1.0' where "VER_ID"=1;
SELECT 'Finished upgrading MetaStore schema from 3.0.1000 to 3.1.0';

-- Upgrading schema to 3.1.1000
SELECT 'Upgrading MetaStore schema from 3.1.0 to 3.1.1000';

-- HIVE-20221
alter table "PARTITION_PARAMS" alter column "PARAM_VALUE" type text using cast("PARAM_VALUE" as text);

-- These lines need to be last.  Insert any changes above.
UPDATE "VERSION" SET "SCHEMA_VERSION"='3.1.1000', "VERSION_COMMENT"='Hive release version 3.1.1000' where "VER_ID"=1;
SELECT 'Finished upgrading MetaStore schema from 3.1.0 to 3.1.1000';

-- Upgrading schema to 3.1.2000
SELECT 'Upgrading MetaStore schema from 3.1.1000 to 3.1.2000';

--- HIVE-22046
ALTER TABLE "TAB_COL_STATS"
ADD COLUMN "ENGINE" character varying(128);

ALTER TABLE "PART_COL_STATS"
ADD COLUMN "ENGINE" character varying(128);

--- Migrate Impala statistics from CDH to CDP. The TAB_COL_STATS table records
--- will be duplicated and the ENGINE field filled.
---
--- 1) Create a temporary table for Impala
CREATE TABLE "TMP_TAB_COL_STATS" AS SELECT * FROM "TAB_COL_STATS";

--- 2) Get where the DataNucleus datastore-identity counter's value and create a SEQUENCE
CREATE SEQUENCE mtablecolumnstatisticsseq;
ALTER TABLE "TMP_TAB_COL_STATS" ALTER COLUMN "CS_ID" SET DEFAULT nextval('mtablecolumnstatisticsseq');
SELECT setval('mtablecolumnstatisticsseq',
    (SELECT "NEXT_VAL"
    FROM "SEQUENCE_TABLE"
    WHERE "SEQUENCE_NAME" = 'org.apache.hadoop.hive.metastore.model.MTableColumnStatistics'));

--- 3) Update the unique ID, ENGINE and number of nulls field
UPDATE "TAB_COL_STATS" SET "ENGINE" = 'hive' WHERE "ENGINE" IS NULL;
UPDATE "PART_COL_STATS" SET "ENGINE" = 'hive' WHERE "ENGINE" IS NULL;
UPDATE "TMP_TAB_COL_STATS" SET "CS_ID" = DEFAULT;
UPDATE "TMP_TAB_COL_STATS" SET "ENGINE" = 'impala' WHERE "ENGINE" IS NULL;

--- 4) Ingest the values back to TAB_COL_STATS
INSERT INTO "TAB_COL_STATS" SELECT * FROM "TMP_TAB_COL_STATS";

--- 5) Update the MTableColumnStatistics with new counter
UPDATE "SEQUENCE_TABLE"
SET "NEXT_VAL" = nextval('mtablecolumnstatisticsseq')
WHERE "SEQUENCE_NAME" = 'org.apache.hadoop.hive.metastore.model.MTableColumnStatistics';

--- 6) Drop the temporary table
DROP TABLE "TMP_TAB_COL_STATS";
DROP SEQUENCE "mtablecolumnstatisticsseq";

DROP INDEX IF EXISTS IDX_RUNTIME_STATS_CREATE_TIME;

ALTER TABLE RUNTIME_STATS
RENAME TO "RUNTIME_STATS";

ALTER TABLE "RUNTIME_STATS"
RENAME COLUMN RS_ID TO "RS_ID";

ALTER TABLE "RUNTIME_STATS"
RENAME COLUMN CREATE_TIME TO "CREATE_TIME";

ALTER TABLE "RUNTIME_STATS"
RENAME COLUMN WEIGHT TO "WEIGHT";

ALTER TABLE "RUNTIME_STATS"
RENAME COLUMN PAYLOAD TO "PAYLOAD";

CREATE INDEX "IDX_RUNTIME_STATS_CREATE_TIME" ON "RUNTIME_STATS"("CREATE_TIME");

-- These lines need to be last.  Insert any changes above.
UPDATE "VERSION" SET "SCHEMA_VERSION"='3.1.2000', "VERSION_COMMENT"='Hive release version 3.1.2000' where "VER_ID"=1;
SELECT 'Finished upgrading MetaStore schema from 3.1.1000 to 3.1.2000';
CREATE TABLE "SCHEDULED_QUERIES" (
	"SCHEDULED_QUERY_ID" BIGINT NOT NULL,
	"CLUSTER_NAMESPACE" VARCHAR(256),
	"ENABLED" boolean NOT NULL,
	"NEXT_EXECUTION" INTEGER,
	"QUERY" VARCHAR(4000),
	"SCHEDULE" VARCHAR(256),
	"SCHEDULE_NAME" VARCHAR(256),
	"USER" VARCHAR(256),
	CONSTRAINT SCHEDULED_QUERIES_PK PRIMARY KEY ("SCHEDULED_QUERY_ID")
);

CREATE TABLE "SCHEDULED_EXECUTIONS" (
	"SCHEDULED_EXECUTION_ID" BIGINT NOT NULL,
	"END_TIME" INTEGER,
	"ERROR_MESSAGE" VARCHAR(2000),
	"EXECUTOR_QUERY_ID" VARCHAR(256),
	"LAST_UPDATE_TIME" INTEGER,
	"SCHEDULED_QUERY_ID" BIGINT,
	"START_TIME" INTEGER,
	"STATE" VARCHAR(256),
	CONSTRAINT SCHEDULED_EXECUTIONS_PK PRIMARY KEY ("SCHEDULED_EXECUTION_ID"),
	CONSTRAINT SCHEDULED_EXECUTIONS_SCHQ_FK FOREIGN KEY ("SCHEDULED_QUERY_ID") REFERENCES "SCHEDULED_QUERIES"("SCHEDULED_QUERY_ID") ON DELETE CASCADE
);

CREATE INDEX IDX_SCHEDULED_EXECUTIONS_LAST_UPDATE_TIME ON "SCHEDULED_EXECUTIONS" ("LAST_UPDATE_TIME");
CREATE INDEX IDX_SCHEDULED_EXECUTIONS_SCHEDULED_QUERY_ID ON "SCHEDULED_EXECUTIONS" ("SCHEDULED_QUERY_ID");
CREATE UNIQUE INDEX UNIQUE_SCHEDULED_EXECUTIONS_ID ON "SCHEDULED_EXECUTIONS" ("SCHEDULED_EXECUTION_ID");

-- HIVE-22728
ALTER TABLE "KEY_CONSTRAINTS" DROP CONSTRAINT "KEY_CONSTRAINTS_pkey";
ALTER TABLE "KEY_CONSTRAINTS" ADD CONSTRAINT "CONSTRAINTS_PK" PRIMARY KEY ("PARENT_TBL_ID", "CONSTRAINT_NAME", "POSITION");

-- HIVE-22729
ALTER TABLE COMPACTION_QUEUE ADD CQ_ERROR_MESSAGE text;
ALTER TABLE COMPLETED_COMPACTIONS ADD CC_ERROR_MESSAGE text;

-- HIVE-22546

ALTER TABLE aux_table RENAME TO "AUX_TABLE";
ALTER TABLE "AUX_TABLE" RENAME COLUMN mt_key1 TO "MT_KEY1";
ALTER TABLE "AUX_TABLE" RENAME COLUMN mt_key2 TO "MT_KEY2";
ALTER TABLE "AUX_TABLE" RENAME COLUMN mt_comment TO "MT_COMMENT";

ALTER TABLE compaction_queue RENAME TO "COMPACTION_QUEUE";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_id TO "CQ_ID";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_database TO "CQ_DATABASE";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_table TO "CQ_TABLE";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_partition TO "CQ_PARTITION";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_state TO "CQ_STATE";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_type TO "CQ_TYPE";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_tblproperties TO "CQ_TBLPROPERTIES";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_worker_id TO "CQ_WORKER_ID";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_start TO "CQ_START";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_run_as TO "CQ_RUN_AS";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_highest_write_id TO "CQ_HIGHEST_WRITE_ID";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_meta_info TO "CQ_META_INFO";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_hadoop_job_id TO "CQ_HADOOP_JOB_ID";
ALTER TABLE "COMPACTION_QUEUE" RENAME COLUMN cq_error_message TO "CQ_ERROR_MESSAGE";

ALTER TABLE completed_compactions RENAME TO "COMPLETED_COMPACTIONS";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_id TO "CC_ID";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_database TO "CC_DATABASE";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_table TO "CC_TABLE";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_partition TO "CC_PARTITION";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_state TO "CC_STATE";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_type TO "CC_TYPE";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_tblproperties TO "CC_TBLPROPERTIES";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_worker_id TO "CC_WORKER_ID";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_start TO "CC_START";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_end TO "CC_END";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_run_as TO "CC_RUN_AS";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_highest_write_id TO "CC_HIGHEST_WRITE_ID";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_meta_info TO "CC_META_INFO";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_hadoop_job_id TO "CC_HADOOP_JOB_ID";
ALTER TABLE "COMPLETED_COMPACTIONS" RENAME COLUMN cc_error_message TO "CC_ERROR_MESSAGE";


ALTER TABLE completed_txn_components RENAME TO "COMPLETED_TXN_COMPONENTS";
ALTER TABLE "COMPLETED_TXN_COMPONENTS" RENAME COLUMN ctc_txnid TO "CTC_TXNID";
ALTER TABLE "COMPLETED_TXN_COMPONENTS" RENAME COLUMN ctc_database TO "CTC_DATABASE";
ALTER TABLE "COMPLETED_TXN_COMPONENTS" RENAME COLUMN ctc_table TO "CTC_TABLE";
ALTER TABLE "COMPLETED_TXN_COMPONENTS" RENAME COLUMN ctc_partition TO "CTC_PARTITION";
ALTER TABLE "COMPLETED_TXN_COMPONENTS" RENAME COLUMN ctc_timestamp TO "CTC_TIMESTAMP";
ALTER TABLE "COMPLETED_TXN_COMPONENTS" RENAME COLUMN ctc_writeid TO "CTC_WRITEID";
ALTER TABLE "COMPLETED_TXN_COMPONENTS" RENAME COLUMN ctc_update_delete TO "CTC_UPDATE_DELETE";

ALTER TABLE hive_locks RENAME TO "HIVE_LOCKS";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_lock_ext_id TO "HL_LOCK_EXT_ID";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_lock_int_id TO "HL_LOCK_INT_ID";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_txnid TO "HL_TXNID";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_db TO "HL_DB";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_table TO "HL_TABLE";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_partition TO "HL_PARTITION";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_lock_state TO "HL_LOCK_STATE";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_lock_type TO "HL_LOCK_TYPE";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_last_heartbeat TO "HL_LAST_HEARTBEAT";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_acquired_at TO "HL_ACQUIRED_AT";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_user TO "HL_USER";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_host TO "HL_HOST";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_heartbeat_count TO "HL_HEARTBEAT_COUNT";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_agent_info TO "HL_AGENT_INFO";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_blockedby_ext_id TO "HL_BLOCKEDBY_EXT_ID";
ALTER TABLE "HIVE_LOCKS" RENAME COLUMN hl_blockedby_int_id TO "HL_BLOCKEDBY_INT_ID";

ALTER TABLE materialization_rebuild_locks RENAME TO "MATERIALIZATION_REBUILD_LOCKS";
ALTER TABLE "MATERIALIZATION_REBUILD_LOCKS" RENAME COLUMN mrl_txn_id TO "MRL_TXN_ID";
ALTER TABLE "MATERIALIZATION_REBUILD_LOCKS" RENAME COLUMN mrl_db_name TO "MRL_DB_NAME";
ALTER TABLE "MATERIALIZATION_REBUILD_LOCKS" RENAME COLUMN mrl_tbl_name TO "MRL_TBL_NAME";
ALTER TABLE "MATERIALIZATION_REBUILD_LOCKS" RENAME COLUMN mrl_last_heartbeat TO "MRL_LAST_HEARTBEAT";

ALTER TABLE min_history_level RENAME TO "MIN_HISTORY_LEVEL";
ALTER TABLE "MIN_HISTORY_LEVEL" RENAME COLUMN mhl_txnid TO "MHL_TXNID";
ALTER TABLE "MIN_HISTORY_LEVEL" RENAME COLUMN mhl_min_open_txnid TO "MHL_MIN_OPEN_TXNID";

ALTER TABLE next_compaction_queue_id RENAME TO "NEXT_COMPACTION_QUEUE_ID";
ALTER TABLE "NEXT_COMPACTION_QUEUE_ID" RENAME COLUMN ncq_next TO "NCQ_NEXT";

ALTER TABLE next_lock_id RENAME TO "NEXT_LOCK_ID";
ALTER TABLE "NEXT_LOCK_ID" RENAME COLUMN nl_next TO "NL_NEXT";

ALTER TABLE next_txn_id RENAME TO "NEXT_TXN_ID";
ALTER TABLE "NEXT_TXN_ID" RENAME COLUMN ntxn_next TO "NTXN_NEXT";

ALTER TABLE next_write_id RENAME TO "NEXT_WRITE_ID";
ALTER TABLE "NEXT_WRITE_ID" RENAME COLUMN nwi_database TO "NWI_DATABASE";
ALTER TABLE "NEXT_WRITE_ID" RENAME COLUMN nwi_table TO "NWI_TABLE";
ALTER TABLE "NEXT_WRITE_ID" RENAME COLUMN nwi_next TO "NWI_NEXT";

ALTER TABLE repl_txn_map RENAME TO "REPL_TXN_MAP";
ALTER TABLE "REPL_TXN_MAP" RENAME COLUMN rtm_repl_policy TO "RTM_REPL_POLICY";
ALTER TABLE "REPL_TXN_MAP" RENAME COLUMN rtm_src_txn_id TO "RTM_SRC_TXN_ID";
ALTER TABLE "REPL_TXN_MAP" RENAME COLUMN rtm_target_txn_id TO "RTM_TARGET_TXN_ID";

ALTER TABLE txn_components RENAME TO "TXN_COMPONENTS";
ALTER TABLE "TXN_COMPONENTS" RENAME COLUMN tc_txnid TO "TC_TXNID";
ALTER TABLE "TXN_COMPONENTS" RENAME COLUMN tc_database TO "TC_DATABASE";
ALTER TABLE "TXN_COMPONENTS" RENAME COLUMN tc_table TO "TC_TABLE";
ALTER TABLE "TXN_COMPONENTS" RENAME COLUMN tc_partition TO "TC_PARTITION";
ALTER TABLE "TXN_COMPONENTS" RENAME COLUMN tc_operation_type TO "TC_OPERATION_TYPE";
ALTER TABLE "TXN_COMPONENTS" RENAME COLUMN tc_writeid TO "TC_WRITEID";

ALTER TABLE txn_to_write_id RENAME TO "TXN_TO_WRITE_ID";
ALTER TABLE "TXN_TO_WRITE_ID" RENAME COLUMN t2w_txnid TO "T2W_TXNID";
ALTER TABLE "TXN_TO_WRITE_ID" RENAME COLUMN t2w_database TO "T2W_DATABASE";
ALTER TABLE "TXN_TO_WRITE_ID" RENAME COLUMN t2w_table TO "T2W_TABLE";
ALTER TABLE "TXN_TO_WRITE_ID" RENAME COLUMN t2w_writeid TO "T2W_WRITEID";

ALTER TABLE txns RENAME TO "TXNS";
ALTER TABLE "TXNS" RENAME COLUMN txn_id TO "TXN_ID";
ALTER TABLE "TXNS" RENAME COLUMN txn_state TO "TXN_STATE";
ALTER TABLE "TXNS" RENAME COLUMN txn_started TO "TXN_STARTED";
ALTER TABLE "TXNS" RENAME COLUMN txn_last_heartbeat TO "TXN_LAST_HEARTBEAT";
ALTER TABLE "TXNS" RENAME COLUMN txn_user TO "TXN_USER";
ALTER TABLE "TXNS" RENAME COLUMN txn_host TO "TXN_HOST";
ALTER TABLE "TXNS" RENAME COLUMN txn_agent_info TO "TXN_AGENT_INFO";
ALTER TABLE "TXNS" RENAME COLUMN txn_meta_info TO "TXN_META_INFO";
ALTER TABLE "TXNS" RENAME COLUMN txn_heartbeat_count TO "TXN_HEARTBEAT_COUNT";
ALTER TABLE "TXNS" RENAME COLUMN txn_type TO "TXN_TYPE";

ALTER TABLE write_set RENAME TO "WRITE_SET";
ALTER TABLE "WRITE_SET" RENAME COLUMN ws_database TO "WS_DATABASE";
ALTER TABLE "WRITE_SET" RENAME COLUMN ws_table TO "WS_TABLE";
ALTER TABLE "WRITE_SET" RENAME COLUMN ws_partition TO "WS_PARTITION";
ALTER TABLE "WRITE_SET" RENAME COLUMN ws_txnid TO "WS_TXNID";
ALTER TABLE "WRITE_SET" RENAME COLUMN ws_commit_id TO "WS_COMMIT_ID";
ALTER TABLE "WRITE_SET" RENAME COLUMN ws_operation_type TO "WS_OPERATION_TYPE";

-- HIVE-21487
CREATE INDEX "COMPLETED_COMPACTIONS_RES" ON "COMPLETED_COMPACTIONS" ("CC_DATABASE","CC_TABLE","CC_PARTITION");

-- HIVE-22546 - backwards compatibility addendum

CREATE OR REPLACE VIEW aux_table
    AS SELECT
        "MT_KEY1" mt_key1,
        "MT_KEY2" mt_key2,
        "MT_COMMENT" mt_comment
    FROM "AUX_TABLE";

CREATE OR REPLACE VIEW compaction_queue
    AS SELECT
        "CQ_ID" cq_id,
        "CQ_DATABASE" cq_database,
        "CQ_TABLE" cq_table,
        "CQ_PARTITION" cq_partition,
        "CQ_STATE" cq_state,
        "CQ_TYPE" cq_type,
        "CQ_TBLPROPERTIES" cq_tblproperties,
        "CQ_WORKER_ID" cq_worker_id,
        "CQ_START" cq_start,
        "CQ_RUN_AS" cq_run_as,
        "CQ_HIGHEST_WRITE_ID" cq_highest_write_id,
        "CQ_META_INFO" cq_meta_info,
        "CQ_HADOOP_JOB_ID" cq_hadoop_job_id,
        "CQ_ERROR_MESSAGE" cq_error_message
    FROM "COMPACTION_QUEUE";

CREATE OR REPLACE VIEW completed_compactions
    AS SELECT
        "CC_ID" cc_id,
        "CC_DATABASE" cc_database,
        "CC_TABLE" cc_table,
        "CC_PARTITION" cc_partition,
        "CC_STATE" cc_state,
        "CC_TYPE" cc_type,
        "CC_TBLPROPERTIES" cc_tblproperties,
        "CC_WORKER_ID" cc_worker_id,
        "CC_START" cc_start,
        "CC_END" cc_end,
        "CC_RUN_AS" cc_run_as,
        "CC_HIGHEST_WRITE_ID" cc_highest_write_id,
        "CC_META_INFO" cc_meta_info,
        "CC_HADOOP_JOB_ID" cc_hadoop_job_id,
        "CC_ERROR_MESSAGE"  cc_error_message
    FROM "COMPLETED_COMPACTIONS";

CREATE OR REPLACE VIEW completed_txn_components
    AS SELECT
        "CTC_TXNID" ctc_txnid,
        "CTC_DATABASE" ctc_database,
        "CTC_TABLE" ctc_table,
        "CTC_PARTITION" ctc_partition,
        "CTC_TIMESTAMP" ctc_timestamp,
        "CTC_WRITEID" ctc_writeid,
        "CTC_UPDATE_DELETE" ctc_update_delete
    FROM "COMPLETED_TXN_COMPONENTS";

CREATE OR REPLACE VIEW hive_locks
    AS SELECT
        "HL_LOCK_EXT_ID" hl_lock_ext_id,
        "HL_LOCK_INT_ID" hl_lock_int_id,
        "HL_TXNID" hl_txnid,
        "HL_DB" hl_db,
        "HL_TABLE" hl_table,
        "HL_PARTITION" hl_partition,
        "HL_LOCK_STATE" hl_lock_state,
        "HL_LOCK_TYPE" hl_lock_type,
        "HL_LAST_HEARTBEAT" hl_last_heartbeat,
        "HL_ACQUIRED_AT" hl_acquired_at,
        "HL_USER" hl_user,
        "HL_HOST" hl_host,
        "HL_HEARTBEAT_COUNT" hl_heartbeat_count,
        "HL_AGENT_INFO" hl_agent_info,
        "HL_BLOCKEDBY_EXT_ID" hl_blockedby_ext_id,
        "HL_BLOCKEDBY_INT_ID" hl_blockedby_int_id
    FROM "HIVE_LOCKS";

CREATE OR REPLACE VIEW materialization_rebuild_locks
    AS SELECT
        "MRL_TXN_ID" mrl_txn_id,
        "MRL_DB_NAME" mrl_db_name,
        "MRL_TBL_NAME" mrl_tbl_name,
        "MRL_LAST_HEARTBEAT" mrl_last_heartbeat
    FROM "MATERIALIZATION_REBUILD_LOCKS";

CREATE OR REPLACE VIEW min_history_level
    AS SELECT
        "MHL_TXNID" mhl_txnid,
        "MHL_MIN_OPEN_TXNID" mhl_min_open_txnid
    FROM "MIN_HISTORY_LEVEL";

CREATE OR REPLACE VIEW next_compaction_queue_id
    AS SELECT
        "NCQ_NEXT" ncq_next
    FROM "NEXT_COMPACTION_QUEUE_ID";

CREATE OR REPLACE VIEW next_lock_id
    AS SELECT
        "NL_NEXT" nl_next
    FROM "NEXT_LOCK_ID";

CREATE OR REPLACE VIEW next_txn_id
    AS SELECT
        "NTXN_NEXT" ntxn_next
    FROM "NEXT_TXN_ID";

CREATE OR REPLACE VIEW next_write_id
    AS SELECT
        "NWI_DATABASE" nwi_database,
        "NWI_TABLE" nwi_table,
        "NWI_NEXT" nwi_next
    FROM "NEXT_WRITE_ID";

CREATE OR REPLACE VIEW repl_txn_map
    AS SELECT
        "RTM_REPL_POLICY" rtm_repl_policy,
        "RTM_SRC_TXN_ID" rtm_src_txn_id,
        "RTM_TARGET_TXN_ID" rtm_target_txn_id
    FROM "REPL_TXN_MAP";

CREATE OR REPLACE VIEW runtime_stats
    AS SELECT
        "RS_ID" rs_id,
        "CREATE_TIME" create_time,
        "WEIGHT" weight,
        "PAYLOAD" payload
    FROM "RUNTIME_STATS";

CREATE OR REPLACE VIEW txn_components
    AS SELECT
        "TC_TXNID" tc_txnid,
        "TC_DATABASE" tc_database,
        "TC_TABLE" tc_table,
        "TC_PARTITION" tc_partition,
        "TC_OPERATION_TYPE" tc_operation_type,
        "TC_WRITEID" tc_writeid
    FROM "TXN_COMPONENTS";

CREATE OR REPLACE VIEW txn_to_write_id
    AS SELECT
        "T2W_TXNID" t2w_txnid,
        "T2W_DATABASE" t2w_database,
        "T2W_TABLE" t2w_table,
        "T2W_WRITEID" t2w_writeid
    FROM "TXN_TO_WRITE_ID";

CREATE OR REPLACE VIEW txns
    AS SELECT
        "TXN_ID" txn_id,
        "TXN_STATE" txn_state,
        "TXN_STARTED" txn_started,
        "TXN_LAST_HEARTBEAT" txn_last_heartbeat,
        "TXN_USER" txn_user,
        "TXN_HOST" txn_host,
        "TXN_AGENT_INFO" txn_agent_info,
        "TXN_META_INFO" txn_meta_info,
        "TXN_HEARTBEAT_COUNT" txn_heartbeat_count,
        "TXN_TYPE" txn_type
    FROM "TXNS";

CREATE OR REPLACE VIEW write_set
    AS SELECT
        "WS_DATABASE" ws_database,
        "WS_TABLE" ws_table,
        "WS_PARTITION" ws_partition,
        "WS_TXNID" ws_txnid,
        "WS_COMMIT_ID" ws_commit_id,
        "WS_OPERATION_TYPE" ws_operation_type
    FROM "WRITE_SET";

-- These lines need to be last.  Insert any changes above.
UPDATE "VERSION" SET "SCHEMA_VERSION"='3.1.3000', "VERSION_COMMENT"='Hive release version 3.1.3000' where "VER_ID"=1;
SELECT 'Finished upgrading MetaStore schema from 3.1.2000 to 3.1.3000';
